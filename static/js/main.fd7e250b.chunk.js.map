{"version":3,"sources":["components/game/grid/grid.module.css","components/app/app.module.css","components/game/game.module.css","components/rules/rules.module.css","components/game/grid/grid-view.tsx","components/game/game-core-rules.ts","components/game/game-ducks.ts","components/game/use-game.ts","components/rules/rules-view.tsx","components/game/game-view.tsx","components/app/app-view.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Grid","grid","onClick","height","length","currY","body","map","row","rowIdx","width","currX","rowOfCells","cellVal","colIdx","cellId","cell","key","x","y","data-testid","className","styles","live","dead","column","table","shouldLive","currentGrid","targetCellLiving","liveNeighborCount","getLiveNeighborCount","target","me","them","cellToCheck","columnIdx","initGameState","size","RangeError","push","nextGeneration","newGrid","newCellState","reducer","state","action","type","newState","cellLocation","payload","newSize","Error","useGame","initialSize","useReducer","gameState","dispatch","useMemo","Rules","rules","Game","useState","running","setRunning","useEffect","timerId","setInterval","clearInterval","section","toggleCell","side","disabled","htmlFor","id","value","onChange","e","App","main","header","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fd7e250b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"table\":\"grid_table__3nmRR\",\"live\":\"grid_live__2m_n1\",\"dead\":\"grid_dead__3kI9j\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"app_main__3yfFw\",\"body\":\"app_body__nzo0i\",\"header\":\"app_header__3NHfP\",\"rules\":\"app_rules__2-hnj\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"section\":\"game_section__2VU5z\",\"side\":\"game_side__3zO36\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"rules\":\"rules_rules__3nzLY\"};","import React from \"react\";\nimport styles from \"./grid.module.css\";\nimport { CellLocation } from \"../game-shared-types\";\n\ntype GridProps = {\n  grid: boolean[][];\n  onClick: (location: CellLocation) => void;\n};\n\nconst Grid = ({ grid, onClick }: GridProps) => {\n  const height = 100 / grid.length;\n  let currY = 0;\n  const body = grid.map((row, rowIdx) => {\n    const width = 100 / row.length;\n    let currX = 0;\n    const rowOfCells = row.map((cellVal, colIdx) => {\n      const cellId = `cell-${rowIdx}-${colIdx}`;\n      const cell = (\n        <rect\n          key={cellId}\n          height={`${height}%`}\n          width={`${width}%`}\n          x={`${currX}%`}\n          y={`${currY}%`}\n          data-testid={cellId}\n          className={cellVal ? styles.live : styles.dead}\n          onClick={() => onClick({ row: rowIdx, column: colIdx })}\n        />\n      );\n      currX += width;\n      return cell;\n    });\n    currY += height;\n    return rowOfCells;\n  });\n\n  return (\n    <svg data-testid=\"Grid\" className={styles.table}>\n      {body}\n    </svg>\n  );\n};\n\nexport default Grid;\n","import { CellLocation } from \"./game-shared-types\";\n\nexport const shouldLive = (\n  currentGrid: boolean[][],\n  rowIdx: number,\n  colIdx: number\n) => {\n  const targetCellLiving = currentGrid[rowIdx][colIdx];\n  const liveNeighborCount = getLiveNeighborCount(currentGrid, {\n    row: rowIdx,\n    column: colIdx\n  });\n\n  if (targetCellLiving && (liveNeighborCount < 2 || liveNeighborCount > 3)) {\n    return false;\n  }\n  if (!targetCellLiving && liveNeighborCount !== 3) {\n    return false;\n  }\n  return true;\n};\n\nexport const isNeighbor = (me: CellLocation, them: CellLocation) => {\n  if (me.row === them.row && me.column === them.column) {\n    return false;\n  }\n\n  if (\n    (them.row === me.row - 1 ||\n      them.row === me.row ||\n      them.row === me.row + 1) &&\n    (them.column === me.column - 1 ||\n      them.column === me.column ||\n      them.column === me.column + 1)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nconst getLiveNeighborCount = (\n  grid: boolean[][],\n  target: CellLocation\n): number => {\n  let liveNeighborCount = 0;\n  const cellToCheck = { row: 0, column: 0 };\n  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {\n    for (let columnIdx = 0; columnIdx < grid[rowIdx].length; columnIdx++) {\n      cellToCheck.row = rowIdx;\n      cellToCheck.column = columnIdx;\n      if (\n        grid[rowIdx][columnIdx] && // if cellToCheck is alive\n        isNeighbor(target, cellToCheck)\n      ) {\n        liveNeighborCount += 1;\n      }\n    }\n  }\n  return liveNeighborCount;\n};\n","import { CellLocation } from \"./game-shared-types\";\nimport { shouldLive } from \"./game-core-rules\";\n\ntype GameState = {\n  grid: boolean[][];\n};\n\nconst TOGGLE_CELL = \"TOGGLE_CELL\";\nconst RESIZE_GRID = \"RESIZE_GRID\";\nconst EVOLVE_NEXT_GENERATION = \"EVOLVE_NEXT_GENERATION\";\n\ntype ToggleCellAction = {\n  type: typeof TOGGLE_CELL;\n  payload: {\n    cellLocation: CellLocation;\n  };\n};\n\ntype ResizeGridAction = {\n  type: typeof RESIZE_GRID;\n  payload: {\n    newSize: number;\n  };\n};\n\ntype EvolveNextGenerationAction = {\n  type: typeof EVOLVE_NEXT_GENERATION;\n  payload: {};\n};\n\ntype GameActionTypes =\n  | ToggleCellAction\n  | ResizeGridAction\n  | EvolveNextGenerationAction;\n\nexport const toggleCell = (cellLocation: CellLocation): GameActionTypes => {\n  return {\n    type: TOGGLE_CELL,\n    payload: {\n      cellLocation\n    }\n  };\n};\n\nexport const resizeGrid = (newSize: number): GameActionTypes => {\n  return {\n    type: RESIZE_GRID,\n    payload: {\n      newSize\n    }\n  };\n};\n\nexport const evolveNextGeneration = (): GameActionTypes => {\n  return {\n    type: EVOLVE_NEXT_GENERATION,\n    payload: {}\n  };\n};\n\nexport const initGameState = (size: number) => {\n  if (size <= 0) {\n    throw new RangeError(\"The size must be greater than 0\");\n  }\n  const grid = [];\n  for (let rowIdx = 0; rowIdx < size; rowIdx++) {\n    const row = [];\n    for (let colIdx = 0; colIdx < size; colIdx++) {\n      row.push(false);\n    }\n    grid.push(row);\n  }\n  return { grid };\n};\n\nconst nextGeneration = (currentGrid: boolean[][]) => {\n  const newGrid = [];\n  for (let rowIdx = 0; rowIdx < currentGrid.length; rowIdx++) {\n    const row = [];\n    for (let colIdx = 0; colIdx < currentGrid[rowIdx].length; colIdx++) {\n      const newCellState = shouldLive(currentGrid, rowIdx, colIdx);\n      row.push(newCellState);\n    }\n    newGrid.push(row);\n  }\n  return newGrid;\n};\n\nconst reducer = (state: GameState, action: GameActionTypes): GameState => {\n  switch (action.type) {\n    case \"TOGGLE_CELL\":\n      const newState = { ...state };\n      const cellLocation = action.payload.cellLocation;\n      const cell = newState.grid[cellLocation.row][cellLocation.column];\n      newState.grid[cellLocation.row][cellLocation.column] = !cell;\n      return newState;\n    case \"RESIZE_GRID\":\n      return initGameState(action.payload.newSize);\n    case \"EVOLVE_NEXT_GENERATION\":\n      return { grid: nextGeneration(state.grid) };\n    default:\n      throw new Error(\"Unrecognized action type\");\n  }\n};\n\nexport default reducer;\n","import { useReducer, useMemo } from \"react\";\nimport reducer, { initGameState } from \"./game-ducks\";\n\nconst useGame = (initialSize: number) => {\n  const [gameState, dispatch] = useReducer(reducer, initialSize, initGameState);\n\n  const size = useMemo(() => {\n    return gameState.grid.length;\n  }, [gameState]);\n\n  return { size, grid: gameState.grid, dispatch };\n};\n\nexport default useGame;\n","import React from \"react\";\nimport styles from \"./rules.module.css\";\n\nconst Rules = () => {\n  return (\n    <section className={styles.rules}>\n      <h2>Rules</h2>\n      <ol>\n        <li>\n          Any live cell with fewer than two live neighbours dies, as if by\n          underpopulation.\n        </li>\n        <li>\n          Any live cell with two or three live neighbours lives on to the next\n          generation.\n        </li>\n        <li>\n          Any live cell with more than three live neighbours dies, as if by\n          overpopulation.\n        </li>\n        <li>\n          Any dead cell with exactly three live neighbours becomes a live cell,\n          as if by reproduction.\n        </li>\n      </ol>\n    </section>\n  );\n};\n\nexport default Rules;\n","import React, { useState, useEffect } from \"react\";\nimport styles from \"./game.module.css\";\nimport Grid from \"./grid\";\nimport useGame from \"./use-game\";\nimport { evolveNextGeneration, resizeGrid, toggleCell } from \"./game-ducks\";\nimport Rules from \"../rules\";\n\nconst Game = () => {\n  const { size, grid, dispatch } = useGame(20);\n  const [running, setRunning] = useState(false);\n  useEffect(() => {\n    let timerId: NodeJS.Timeout;\n    if (running) {\n      timerId = setInterval(() => {\n        dispatch(evolveNextGeneration());\n      }, 100);\n      return () => {\n        clearInterval(timerId);\n      };\n    }\n  }, [running, dispatch]);\n\n  return (\n    <section className={styles.section}>\n      <h2>Game</h2>\n      <Grid\n        grid={grid}\n        onClick={cellLocation => dispatch(toggleCell(cellLocation))}\n      />\n      <section className={styles.side}>\n        <p>\n          Click cells on the grid to create a starting pattern. Then click Play\n          to start the game.\n        </p>\n        <div className=\"btn-grp\">\n          <button disabled={running} onClick={() => setRunning(true)}>\n            Play\n          </button>\n          <button disabled={!running} onClick={() => setRunning(false)}>\n            Stop\n          </button>\n          <button\n            disabled={running}\n            onClick={() => dispatch(evolveNextGeneration())}\n          >\n            Step\n          </button>\n        </div>\n        <fieldset>\n          <label htmlFor=\"size\">Grid Size</label>\n          <input\n            type=\"number\"\n            id=\"size\"\n            value={size}\n            onChange={e => dispatch(resizeGrid(+e.target.value))}\n          />\n        </fieldset>\n        <Rules />\n      </section>\n    </section>\n  );\n};\n\nexport default Game;\n","import React from \"react\";\nimport styles from \"./app.module.css\";\nimport Game from \"../game\";\n\nconst App = () => {\n  return (\n    <div className={styles.main}>\n      <header className={styles.header}>\n        <h1>Conway&apos;s Game of Life</h1>\n      </header>\n      <Game />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/app\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}