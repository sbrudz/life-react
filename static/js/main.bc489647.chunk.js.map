{"version":3,"sources":["components/game/grid/grid.module.css","components/app/app.module.css","components/game/game.module.css","components/rules/rules.module.css","components/game/grid/grid-view.tsx","components/game/game-core-rules.ts","components/game/game-utils.ts","components/game/game-ducks.ts","components/game/use-game.ts","components/rules/rules-view.tsx","components/game/game-button-panel.tsx","components/game/game-view.tsx","components/app/app-view.tsx","index.tsx"],"names":["module","exports","Grid","grid","onClick","height","length","currY","body","map","row","rowIdx","width","currX","rowOfCells","cellVal","colIdx","cellId","cell","x","y","className","styles","live","dead","column","table","shouldLive","currentGrid","targetCellLiving","liveNeighborCount","getLiveNeighborCount","target","me","them","cellToCheck","columnIdx","liveCellCounter","rowCt","ERROR_MESSAGES","encodeGridState","Error","cellCount","base","Array","index","bitfield","join","compressToEncodedURIComponent","TOGGLE_CELL","RESIZE_GRID","EVOLVE_NEXT_GENERATION","START_GAME","STOP_GAME","CLEAR_GAME","evolveNextGeneration","type","payload","initGameState","size","RangeError","push","running","initCode","reducer","state","action","newGrid","slice","cellLocation","newSize","newCellState","nextGeneration","useGame","defaultGridSize","useReducer","gameState","dispatch","liveCellCount","countingMethod","reduce","prevRowCellCt","countCellsInRow","countCells","useEffect","timerId","setInterval","clearInterval","Rules","rules","GameButtonPanel","disabled","Game","section","toggleCell","side","htmlFor","id","value","onChange","e","App","main","header","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bc489647.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"table\":\"grid_table__3nmRR\",\"live\":\"grid_live__2m_n1\",\"dead\":\"grid_dead__3kI9j\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"app_main__3yfFw\",\"body\":\"app_body__nzo0i\",\"header\":\"app_header__3NHfP\",\"rules\":\"app_rules__2-hnj\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"section\":\"game_section__2VU5z\",\"side\":\"game_side__3zO36\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"rules\":\"rules_rules__3nzLY\"};","import React from \"react\";\nimport styles from \"./grid.module.css\";\nimport { CellLocation, ImmutableGrid } from \"../game-shared-types\";\n\ntype GridProps = {\n  grid: ImmutableGrid;\n  onClick: (location: CellLocation) => void;\n};\n\nconst Grid = ({ grid, onClick }: GridProps) => {\n  const height = 100 / grid.length;\n  let currY = 0;\n  const body = grid.map((row, rowIdx) => {\n    const width = 100 / row.length;\n    let currX = 0;\n    const rowOfCells = row.map((cellVal, colIdx) => {\n      const cellId = `cell-${rowIdx}-${colIdx}`;\n      const cell = (\n        <rect\n          key={cellId}\n          height={`${height}%`}\n          width={`${width}%`}\n          x={`${currX}%`}\n          y={`${currY}%`}\n          data-testid={cellId}\n          className={cellVal ? styles.live : styles.dead}\n          onClick={() => onClick({ row: rowIdx, column: colIdx })}\n        />\n      );\n      currX += width;\n      return cell;\n    });\n    currY += height;\n    return rowOfCells;\n  });\n\n  return (\n    <svg data-testid=\"Grid\" className={styles.table}>\n      {body}\n    </svg>\n  );\n};\n\nexport default Grid;\n","import { CellLocation, ImmutableGrid } from \"./game-shared-types\";\n\nexport const shouldLive = (\n  currentGrid: ImmutableGrid,\n  rowIdx: number,\n  colIdx: number\n) => {\n  const targetCellLiving = currentGrid[rowIdx][colIdx];\n  const liveNeighborCount = getLiveNeighborCount(currentGrid, {\n    row: rowIdx,\n    column: colIdx\n  });\n\n  if (targetCellLiving && (liveNeighborCount < 2 || liveNeighborCount > 3)) {\n    return false;\n  }\n  if (!targetCellLiving && liveNeighborCount !== 3) {\n    return false;\n  }\n  return true;\n};\n\nexport const isNeighbor = (me: CellLocation, them: CellLocation) => {\n  if (me.row === them.row && me.column === them.column) {\n    return false;\n  }\n\n  if (\n    (them.row === me.row - 1 ||\n      them.row === me.row ||\n      them.row === me.row + 1) &&\n    (them.column === me.column - 1 ||\n      them.column === me.column ||\n      them.column === me.column + 1)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nconst getLiveNeighborCount = (\n  grid: ImmutableGrid,\n  target: CellLocation\n): number => {\n  let liveNeighborCount = 0;\n  const cellToCheck = { row: 0, column: 0 };\n  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {\n    for (let columnIdx = 0; columnIdx < grid[rowIdx].length; columnIdx++) {\n      cellToCheck.row = rowIdx;\n      cellToCheck.column = columnIdx;\n      if (\n        grid[rowIdx][columnIdx] && // if cellToCheck is alive\n        isNeighbor(target, cellToCheck)\n      ) {\n        liveNeighborCount += 1;\n      }\n    }\n  }\n  return liveNeighborCount;\n};\n","import {\n  compressToEncodedURIComponent,\n  decompressFromEncodedURIComponent\n} from \"lz-string\";\nimport { ImmutableGrid, ImmutableGridRow } from \"./game-shared-types\";\n\ntype CountingMethod = {\n  (rowCt: number, cell: boolean): number;\n};\n\n/**\n * A counting method used by countAllCells to count the number of dead cells\n *\n * @param rowCt aggregate count of dead cells for the row\n * @param cell the cell being counted\n */\nexport const deadCellCounter: CountingMethod = (rowCt: number, cell: boolean) =>\n  cell ? rowCt : rowCt + 1;\n\n/**\n * A counting method used by countAllCells to count the number of living cells\n *\n * @param rowCt aggregate count of living cells for the row\n * @param cell the cell being counted\n */\nexport const liveCellCounter: CountingMethod = (rowCt: number, cell: boolean) =>\n  !cell ? rowCt : rowCt + 1;\n\n/**\n * Counts the number of cells in a row of a grid that fit the criteria defined by countingMethod\n *\n * @param countingMethod the function used to do the counting\n */\nconst countCellsInRow = (countingMethod: CountingMethod) => (\n  prevRowCellCt: number,\n  row: ImmutableGridRow\n): number => row.reduce(countingMethod, prevRowCellCt);\n\n/**\n * Counts the cells in the grid using the given countingMethod\n */\nexport const countCells = (\n  grid: ImmutableGrid,\n  countingMethod: CountingMethod\n): number => {\n  return grid.reduce(countCellsInRow(countingMethod), 0);\n};\n\nexport const ERROR_MESSAGES = {\n  INVALID_GRID_ERROR: \"Invalid grid. Unable to encode grid state.\",\n  EMPTY_BITFIELD_ERROR:\n    \"Bitfield cannot be empty. Unable to reconstruct grid state.\",\n  INVALID_BITFIELD_ERROR: \"Invalid bitfield. Unable to reconstruct grid state.\"\n};\n\nexport const encodeGridState = (grid: ImmutableGrid): string => {\n  if (grid === null || grid.length === 0 || grid[0].length === 0) {\n    throw new Error(ERROR_MESSAGES.INVALID_GRID_ERROR);\n  }\n  const cellCount = grid.length * grid.length;\n  const base = new Array(cellCount + 1);\n  base[0] = \"1\"; // first bit is always 1 so that empty grids are handled properly\n  let index = 1;\n  for (let rowIdx = 0; rowIdx < grid.length; rowIdx++) {\n    for (let columnIdx = 0; columnIdx < grid[rowIdx].length; columnIdx++) {\n      base[index] = grid[rowIdx][columnIdx] ? \"1\" : \"0\";\n      index++;\n    }\n  }\n  const bitfield = base.join(\"\");\n  return compressToEncodedURIComponent(bitfield);\n};\n\nexport const decodeGridState = (compressedBitfield: string): ImmutableGrid => {\n  if (!compressedBitfield) {\n    throw new Error(ERROR_MESSAGES.EMPTY_BITFIELD_ERROR);\n  }\n  const bitfield = decompressFromEncodedURIComponent(compressedBitfield);\n  if (!bitfield) {\n    throw new Error(ERROR_MESSAGES.INVALID_BITFIELD_ERROR);\n  }\n  const gridSize = Math.sqrt(bitfield.length - 1);\n  if (!Number.isInteger(gridSize) || gridSize <= 0) {\n    throw new Error(ERROR_MESSAGES.INVALID_BITFIELD_ERROR);\n  }\n  const grid: boolean[][] = new Array(gridSize);\n  let index = 1;\n  for (let rowIdx = 0; rowIdx < gridSize; rowIdx++) {\n    const row = new Array(gridSize);\n    for (let columnIdx = 0; columnIdx < gridSize; columnIdx++) {\n      row[columnIdx] = bitfield[index] === \"1\" ? true : false;\n      index++;\n    }\n    grid[rowIdx] = row;\n  }\n  return grid;\n};\n","import { CellLocation, ImmutableGrid } from \"./game-shared-types\";\nimport { shouldLive } from \"./game-core-rules\";\nimport { encodeGridState } from \"./game-utils\";\n\ntype GameState = {\n  grid: ImmutableGrid;\n  readonly running: boolean;\n  readonly initCode: string;\n};\n\nconst TOGGLE_CELL = \"TOGGLE_CELL\";\nconst RESIZE_GRID = \"RESIZE_GRID\";\nconst EVOLVE_NEXT_GENERATION = \"EVOLVE_NEXT_GENERATION\";\nconst START_GAME = \"START_GAME\";\nconst STOP_GAME = \"STOP_GAME\";\nconst CLEAR_GAME = \"CLEAR_GAME\";\n\ntype ToggleCellAction = {\n  type: typeof TOGGLE_CELL;\n  payload: {\n    cellLocation: CellLocation;\n  };\n};\n\ntype ResizeGridAction = {\n  type: typeof RESIZE_GRID;\n  payload: {\n    newSize: number;\n  };\n};\n\ntype EvolveNextGenerationAction = {\n  type: typeof EVOLVE_NEXT_GENERATION;\n  payload: {};\n};\n\ntype StartGameAction = {\n  type: typeof START_GAME;\n  payload: {};\n};\n\ntype StopGameAction = {\n  type: typeof STOP_GAME;\n  payload: {};\n};\n\ntype ClearGameAction = {\n  type: typeof CLEAR_GAME;\n  payload: {};\n};\n\nexport type GameActionTypes =\n  | ToggleCellAction\n  | ResizeGridAction\n  | EvolveNextGenerationAction\n  | StartGameAction\n  | StopGameAction\n  | ClearGameAction;\n\nexport const toggleCell = (cellLocation: CellLocation): GameActionTypes => {\n  return {\n    type: TOGGLE_CELL,\n    payload: {\n      cellLocation\n    }\n  };\n};\n\nexport const resizeGrid = (newSize: number): GameActionTypes => {\n  return {\n    type: RESIZE_GRID,\n    payload: {\n      newSize\n    }\n  };\n};\n\nexport const evolveNextGeneration = (): GameActionTypes => {\n  return {\n    type: EVOLVE_NEXT_GENERATION,\n    payload: {}\n  };\n};\n\nexport const startGame = (): GameActionTypes => {\n  return {\n    type: START_GAME,\n    payload: {}\n  };\n};\n\nexport const stopGame = (): GameActionTypes => {\n  return {\n    type: STOP_GAME,\n    payload: {}\n  };\n};\n\nexport const clearGame = (): GameActionTypes => {\n  return {\n    type: CLEAR_GAME,\n    payload: {}\n  };\n};\n\nexport const initGameState = (size: number) => {\n  if (size <= 0) {\n    throw new RangeError(\"The size must be greater than 0\");\n  }\n  const grid = [];\n  for (let rowIdx = 0; rowIdx < size; rowIdx++) {\n    const row = [];\n    for (let colIdx = 0; colIdx < size; colIdx++) {\n      row.push(false);\n    }\n    grid.push(row);\n  }\n  const initCode = encodeGridState(grid);\n  return { grid, running: false, initCode };\n};\n\nconst nextGeneration = (currentGrid: ImmutableGrid) => {\n  const newGrid = [];\n  for (let rowIdx = 0; rowIdx < currentGrid.length; rowIdx++) {\n    const row = [];\n    for (let colIdx = 0; colIdx < currentGrid[rowIdx].length; colIdx++) {\n      const newCellState = shouldLive(currentGrid, rowIdx, colIdx);\n      row.push(newCellState);\n    }\n    newGrid.push(row);\n  }\n  return newGrid;\n};\n\nconst reducer = (state: GameState, action: GameActionTypes): GameState => {\n  switch (action.type) {\n    case TOGGLE_CELL:\n      const newGrid = state.grid.map(row => row.slice());\n      const { row, column } = action.payload.cellLocation;\n      newGrid[row][column] = !state.grid[row][column];\n      const initCode = encodeGridState(newGrid);\n      return { ...state, grid: newGrid, initCode };\n    case RESIZE_GRID:\n      return initGameState(action.payload.newSize);\n    case EVOLVE_NEXT_GENERATION:\n      const grid = nextGeneration(state.grid);\n      return { ...state, grid };\n    case START_GAME:\n      return { ...state, running: true };\n    case STOP_GAME:\n      return { ...state, running: false };\n    case CLEAR_GAME:\n      return initGameState(state.grid.length);\n    default:\n      throw new Error(\"Unrecognized action type\");\n  }\n};\n\nexport default reducer;\n","import { useReducer, useEffect } from \"react\";\nimport reducer, { evolveNextGeneration, initGameState } from \"./game-ducks\";\nimport { countCells, liveCellCounter } from \"./game-utils\";\n\nconst useGame = (defaultGridSize: number) => {\n  const [gameState, dispatch] = useReducer(\n    reducer,\n    defaultGridSize,\n    initGameState\n  );\n  const { grid, running } = gameState;\n  const size = grid.length;\n  const liveCellCount = countCells(grid, liveCellCounter);\n\n  useEffect(() => {\n    let timerId: NodeJS.Timeout;\n    if (running) {\n      timerId = setInterval(() => {\n        dispatch(evolveNextGeneration());\n      }, 100);\n      return () => {\n        clearInterval(timerId);\n      };\n    }\n  }, [running, dispatch]);\n\n  return { size, grid, running, liveCellCount, dispatch };\n};\n\nexport default useGame;\n","import React from \"react\";\nimport styles from \"./rules.module.css\";\n\nconst Rules = () => {\n  return (\n    <section className={styles.rules}>\n      <h2>Rules</h2>\n      <ol>\n        <li>\n          Any live cell with fewer than two live neighbours dies, as if by\n          underpopulation.\n        </li>\n        <li>\n          Any live cell with two or three live neighbours lives on to the next\n          generation.\n        </li>\n        <li>\n          Any live cell with more than three live neighbours dies, as if by\n          overpopulation.\n        </li>\n        <li>\n          Any dead cell with exactly three live neighbours becomes a live cell,\n          as if by reproduction.\n        </li>\n      </ol>\n    </section>\n  );\n};\n\nexport default Rules;\n","import React, { Dispatch } from \"react\";\nimport {\n  GameActionTypes,\n  clearGame,\n  evolveNextGeneration,\n  startGame,\n  stopGame\n} from \"./game-ducks\";\n\ntype GameButtonPanelProps = {\n  running: boolean;\n  liveCellCount: number;\n  dispatch: Dispatch<GameActionTypes>;\n};\n\nconst GameButtonPanel = ({\n  running,\n  dispatch,\n  liveCellCount\n}: GameButtonPanelProps) => {\n  return (\n    <div className=\"btn-grp\">\n      <button disabled={running} onClick={() => dispatch(startGame())}>\n        Play\n      </button>\n      <button disabled={!running} onClick={() => dispatch(stopGame())}>\n        Stop\n      </button>\n      <button\n        disabled={running}\n        onClick={() => dispatch(evolveNextGeneration())}\n      >\n        Step\n      </button>\n      <button\n        disabled={liveCellCount === 0}\n        onClick={() => dispatch(clearGame())}\n      >\n        Clear\n      </button>\n    </div>\n  );\n};\n\nexport default GameButtonPanel;\n","import React from \"react\";\nimport styles from \"./game.module.css\";\nimport Grid from \"./grid\";\nimport useGame from \"./use-game\";\nimport { resizeGrid, toggleCell } from \"./game-ducks\";\nimport Rules from \"../rules\";\nimport GameButtonPanel from \"./game-button-panel\";\n\nconst Game = () => {\n  const { size, grid, running, liveCellCount, dispatch } = useGame(20);\n\n  return (\n    <section className={styles.section}>\n      <h2>Game</h2>\n      <Grid\n        grid={grid}\n        onClick={cellLocation => dispatch(toggleCell(cellLocation))}\n      />\n      <section className={styles.side}>\n        <p>\n          Click cells on the grid to create a starting pattern. Then click Play\n          to start the game.\n        </p>\n        <GameButtonPanel\n          running={running}\n          liveCellCount={liveCellCount}\n          dispatch={dispatch}\n        />\n        <fieldset>\n          <label htmlFor=\"size\">Grid Size</label>\n          <input\n            type=\"number\"\n            id=\"size\"\n            value={size}\n            onChange={e => dispatch(resizeGrid(+e.target.value))}\n          />\n        </fieldset>\n        <Rules />\n      </section>\n    </section>\n  );\n};\n\nexport default Game;\n","import React from \"react\";\nimport styles from \"./app.module.css\";\nimport Game from \"../game\";\n\nconst App = () => {\n  return (\n    <div className={styles.main}>\n      <header className={styles.header}>\n        <h1>Conway&apos;s Game of Life</h1>\n      </header>\n      <Game />\n    </div>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/app\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}